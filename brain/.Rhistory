XTrn_P <- as.data.frame(MLMatrix[datosParaTRN, ])  # Datos de entrenamiento
XTest_P <- as.data.frame(MLMatrix[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(MLLabels[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(MLLabels[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn, select=huella), decay = best_decay)
# Predicciones en Train
predTrain <- predict(modelo, XTest_P[, huella])
confMatTrain <- confusionMatrix(as.factor(predTrain), YTest_P)
ACCTrnRL[particion] <- confMatTrain$overall["Accuracy"]
# Predicciones en Test
predTest <- predict(modelo, t(XTest)[, huella])
confMatTest <- confusionMatrix(as.factor(predTest), YTest)
#print(confMatTest$table)
ACCTestRL[particion] <- confMatTest$overall["Accuracy"]
#print(ACCTestSVM[particion])
# Sumar la matriz de confusión al total
accTestSum <- accTestSum + confMatTest$table
}
t(XTest)[, huella]
predict(modelo, t(XTest)[, huella])
modelo
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(MLLabels, nfolds)  # Particiones estratificadas
numGenes <- 5  # Número fijo de genes seleccionados
PREDICCIONES_RL <- numeric(length(MLLabels))  # Vector para almacenar predicciones
# Vectores para almacenar métricas por partición
ACCTrnRL <- numeric(nfolds)
ACCTestRL <- numeric(nfolds)
# Matriz de confusión acumulada para el test
accTestSum <- matrix(0, nrow = length(unique(MLLabels)), ncol = length(unique(MLLabels)))
# Ranking con mRMR
huella <- c("IGHV3-73", "IGHV6-1", "UBQLN4P1", "PI4K2B", "RAPH1")
# Bucle para 5 particiones
for (particion in seq_len(nfolds)) {
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame(MLMatrix[datosParaTRN, ])  # Datos de entrenamiento
XTest_P <- as.data.frame(MLMatrix[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(MLLabels[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(MLLabels[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
# Predicciones en Train
predTrain <- predict(modelo, XTest_P[, huella])
confMatTrain <- confusionMatrix(as.factor(predTrain), YTest_P)
ACCTrnRL[particion] <- confMatTrain$overall["Accuracy"]
# Predicciones en Test
predTest <- predict(modelo, t(XTest)[, huella])
confMatTest <- confusionMatrix(as.factor(predTest), YTest)
#print(confMatTest$table)
ACCTestRL[particion] <- confMatTest$overall["Accuracy"]
#print(ACCTestSVM[particion])
# Sumar la matriz de confusión al total
accTestSum <- accTestSum + confMatTest$table
}
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame(MLMatrix[datosParaTRN, ])  # Datos de entrenamiento
XTest_P <- as.data.frame(MLMatrix[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(MLLabels[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(MLLabels[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
# Predicciones en Train
predTrain <- predict(modelo, XTest_P[, huella])
confMatTrain <- confusionMatrix(as.factor(predTrain), YTest_P)
ACCTrnRL[particion] <- confMatTrain$overall["Accuracy"]
# Predicciones en Test
predTest <- predict(modelo, t(XTest)[, huella])
confMatTest <- confusionMatrix(as.factor(predTest), YTest)
predTest
YTest
confMatTest <- confusionMatrix(as.factor(predTest), YTest)
confMatTest <- confusionMatrix(as.factor(predTest), as.factor(YTest))
#print(confMatTest$table)
ACCTestRL[particion] <- confMatTest$overall["Accuracy"]
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(MLLabels, nfolds)  # Particiones estratificadas
numGenes <- 5  # Número fijo de genes seleccionados
PREDICCIONES_RL <- numeric(length(MLLabels))  # Vector para almacenar predicciones
# Vectores para almacenar métricas por partición
ACCTrnRL <- numeric(nfolds)
ACCTestRL <- numeric(nfolds)
# Matriz de confusión acumulada para el test
accTestSum <- matrix(0, nrow = length(unique(MLLabels)), ncol = length(unique(MLLabels)))
# Ranking con mRMR
huella <- c("IGHV3-73", "IGHV6-1", "UBQLN4P1", "PI4K2B", "RAPH1")
# Bucle para 5 particiones
for (particion in seq_len(nfolds)) {
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame(MLMatrix[datosParaTRN, ])  # Datos de entrenamiento
XTest_P <- as.data.frame(MLMatrix[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(MLLabels[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(MLLabels[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
# Predicciones en Train
predTrain <- predict(modelo, XTest_P[, huella])
confMatTrain <- confusionMatrix(as.factor(predTrain), YTest_P)
ACCTrnRL[particion] <- confMatTrain$overall["Accuracy"]
# Predicciones en Test
predTest <- predict(modelo, t(XTest)[, huella])
confMatTest <- confusionMatrix(as.factor(predTest), as.factor(YTest))
#print(confMatTest$table)
ACCTestRL[particion] <- confMatTest$overall["Accuracy"]
#print(ACCTestSVM[particion])
# Sumar la matriz de confusión al total
accTestSum <- accTestSum + confMatTest$table
}
print("Matriz de confusión acumulada en el test:")
accTestSum
# Filtrar los datos para incluir solo los genes seleccionados
X_selected <- as.data.frame( MLMatrix[, c("IGHV3-73", "IGHV6-1", "UBQLN4P1", "PI4K2B", "RAPH1")])# Seleccionar columnas correspondientes
Y <- as.factor(MLLabels)  # Etiquetas de clase
# Crear particiones: 80% Train, 20% Test
set.seed(19)
trainIndex <- createDataPartition(Y, p = 0.8, list = FALSE)
X_train <- X_selected[trainIndex, ]
Y_train <- Y[trainIndex]
X_test <- X_selected[-trainIndex, ]
Y_test <- Y[-trainIndex]
# GridSearch para Regresión Logística Multinomial: Definir el parámetro decay a probar
grid <- expand.grid(.decay = c(0.0001, 0.01, 0.1, 1))
# Entrenar el modelo con validación cruzada
train_control <- trainControl(method = "cv", number = 5)  # Validación cruzada de 5 pliegues
# Modelo de Regresión Logística Multinomial
logistic_model <- train(x = X_train, y = Y_train, method = "multinom", trControl = train_control, tuneGrid = grid)
# Mejores hiperparámetros encontrados
best_params <- logistic_model$bestTune
best_params
# Entrenar el modelo con el mejor parámetro decay
final_model <- multinom(Y_train ~ ., data = cbind(X_train, Y_train), decay = best_params$decay)
# Predicciones en el conjunto de prueba
pred_test <- predict(final_model, X_test)
conf_matrix <- confusionMatrix(pred_test, Y_test)
conf_matrix
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(MLLabels, nfolds)  # Particiones estratificadas
nVarsMAX <- 20  # Número máximo de genes a seleccionar, en un ejercicio de clase se aumentó hasta 50
# Matrices para almacenar métricas por partición
ACCTrnRL <- matrix(0, nfolds, nVarsMAX)
ACCTestRL <- matrix(0, nfolds, nVarsMAX)
# Para almacenar los ranking de características de cada partición
rankingSMRMR <- matrix(0, nfolds, nVarsMAX)
# El Mejor hiperparámetro decay obtenido en la sección enterior
best_decay<-logistic_trn_mrmr$logisticModel$finalModel$decay
print(best_decay)
# Bucle para 5 particiones
for (particion in seq(1, nfolds)) {
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame( MLMatrix[datosParaTRN, ] ) # Datos de entrenamiento
XTest_P <- as.data.frame(MLMatrix[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(MLLabels[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(MLLabels[segmentoTest])  # Etiquetas de prueba
# Ranking con mRMR
rankingMRMR <-featureSelection(XTrn_P, YTrn_P, mode = "mrmr", vars_selected = colnames(XTrn_P))
# Guardar POR FILAS el ranking de características para esta partición
rankingSMRMR[particion, ] <- rankingMRMR[1:nVarsMAX]
# Evaluación por número de genes seleccionados
for (numGenes in seq_len(nVarsMAX)) {
# Seleccionar las mejores variables
topGenes <- colnames(XTrn_P)[rankingMRMR[1:numGenes]]
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=topGenes), decay = best_decay)
# Predicciones en Train
predTrain <- predict(modelo, subset(XTest_P, select=topGenes))
confMatTrain <- confusionMatrix(as.factor(predTrain), as.factor(YTest_P))
ACCTrnRL[particion, numGenes] <- confMatTrain$overall["Accuracy"]
# Predicciones en Test
predTest <- predict(modelo, subset(t(XTest), select=topGenes))
confMatTest <- confusionMatrix(as.factor(predTest), as.factor(YTest))
ACCTestRL[particion, numGenes] <- confMatTest$overall["Accuracy"] # se van añadiendo los valores por filas. Por tanto, para calcular la media de los accuracy para un número determinado de genes que hacerlo por columnas.  #print(confMatTest$overall[1])
#print(confMatTest$table)
}
# Graficar los resultados para la partición actual
num_genes <- 1:nVarsMAX
Trn_Acc <- ACCTrnRL[particion, 1:nVarsMAX]
Test_Acc <- ACCTestRL[particion, 1:nVarsMAX]
plot(num_genes, Trn_Acc, type = "l", col = "green", ylim = c(0.5, 1), ylab = "Accuracy",        xlab = "Número de genes seleccionados", main = paste("Partición", particion, "- RL con mRMR"))
lines(num_genes, Test_Acc, col = "black")
axis(1, at = 1:20, labels = 1:20)  # Configura los ticks y etiquetas del eje X
grid()
legend("topleft", legend = c("Train Accuracy", "Test Accuracy"),col=c("green","black"),lty = c(1, 1))
}
# Medias de Accuracy en las 5 particiones
ACCTrnRL_Mean <- colMeans(ACCTrnRL)
ACCTestRL_Mean <- colMeans(ACCTestRL)
# Resultados promedio
plot(1:nVarsMAX, ACCTrnRL_Mean, type = "l", col = "green", ylim = c(0.5, 1), xlim=c(1,20), xlab = "Número de genes seleccionados", ylab = "Accuracy", main = "Resultados Promedio RL con mRMR")
lines(1:nVarsMAX, ACCTestRL_Mean, col = "black")
axis(1, at = 1:20, labels = 1:20)  # Configura los ticks y etiquetas del eje X
grid()
legend("topleft", legend = c("Train Accuracy", "Test Accuracy"), col = c("green", "black"),
lty = c(1, 1))
# Se observan la variable rankingSMRMR
rankingSMRMR[,1:10]
# rankingMRMR de la última iteración pero solo lo utilizamos para saber el nombre de los genes
colnames(MLMatrix)[c(170, 81, 51, 41, 10,16)]
#ENRIQUECIMIENTO FUNCIONAL:
entrezAnnotation <- getGenesAnnotation(c("IGHV3-73", "IGHV6-1", "UBQLN4P1", "PI4K2B", "RAPH1", 'STXBP2'), attributes = c("external_gene_name","entrezgene_id"), filter = "external_gene_name")
entrezGeneIds<- entrezAnnotation$entrezgene_id[!is.na(entrezAnnotation$entrezgene_id)]
entrezAnnotation
particion<-1
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(LABELS, nfolds)  # Particiones estratificadas
nVarsMAX <- 20  # Número máximo de genes a seleccionar, en un ejercicio de clase se aumentó hasta 50
# Matrices para almacenar métricas por partición
ACCTrnRL <- matrix(0, nfolds, nVarsMAX)
ACCTestRL <- matrix(0, nfolds, nVarsMAX)
# Para almacenar los ranking de características de cada partición
rankingSMRMR <- matrix(0, nfolds, nVarsMAX)
# El Mejor hiperparámetro decay obtenido en la sección enterior
best_decay<-logistic_trn_mrmr$logisticModel$finalModel$decay
print(best_decay)
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame( MATRIZ[datosParaTRN, ] ) # Datos de entrenamiento
XTrn_P <- as.data.frame( MATRIZ[datosParaTRN, ] ) # Datos de entrenamiento
XTest_P <- as.data.frame(MATRIZ[segmentoTest, ])  # Datos de prueba
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
# Ranking con mRMR
rankingMRMR <-featureSelection(XTrn_P, YTrn_P, mode = "mrmr", vars_selected = colnames(XTrn_P))
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(LABELS, nfolds)  # Particiones estratificadas
# Vectores para almacenar métricas por partición
ACCTrnRL <- numeric(nfolds)
ACCTestRL <- numeric(nfolds)
# Matriz de confusión acumulada para el test
accTestSum <- matrix(0, nrow = 3, ncol = 3)
# Ranking con mRMR
huella <- c("IGHV3-73", "IGHV6-1", "UBQLN4P1", "PI4K2B", "RAPH1")
particion
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame(MATRIZ[datosParaTRN, ])  # Datos de entrenamiento
XTest_P <- as.data.frame(MATRIZ[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(LABELS[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
subset(XTrn_P, select=huella)
huella%in%colanmes(XTran_P)
huella%in%colnames(XTran_P)
XTrn_P <- as.data.frame(MATRIZ[datosParaTRN, ])  # Datos de entrenamiento
XTest_P <- as.data.frame(MATRIZ[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(LABELS[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
huella %in% colnames(XTrn_P)
huella %in% rownames(XTrn_P)
XTrn_P <- MATRIZ[datosParaTRN, ] # Datos de entrenamiento
huella %in% colnames(XTrn_P)
huella %in% rownames(XTrn_P)
XTrn_P <- MATRIZ[datosParaTRN, ] # Datos de entrenamiento
XTest_P <- MATRIZ[segmentoTest, ]  # Datos de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
XTrn_P
huella %in% rownames(XTrn_P)
huella %in% colnames(XTrn_P)
colnames(XTrn_P)
rownames(XTrn_P)
"IGHV3-73"%in%rownames(XTrn_P)
"IGHV3-73"%in%rownames(XTest_P)
"IGHV3.73"%in%rownames(XTrn_P)
"IGHV3.73"%in%rownames(XTest_P)
huella %in% rownames(XTest_P)
huella %in% rownames(XTrn_P)
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(MLLabels, nfolds)  # Particiones estratificadas
nVarsMAX <- 20  # Número máximo de genes a seleccionar, en un ejercicio de clase se aumentó hasta 50
# Matrices para almacenar métricas por partición
ACCTrnRL <- matrix(0, nfolds, nVarsMAX)
ACCTestRL <- matrix(0, nfolds, nVarsMAX)
# Para almacenar los ranking de características de cada partición
rankingSMRMR <- matrix(0, nfolds, nVarsMAX)
# El Mejor hiperparámetro decay obtenido en la sección enterior
best_decay<-logistic_trn_mrmr$logisticModel$finalModel$decay
print(best_decay)
# Bucle para 5 particiones
for (particion in seq(1, nfolds)) {
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame( MLMatrix[datosParaTRN, ] ) # Datos de entrenamiento
XTest_P <- as.data.frame(MLMatrix[segmentoTest, ])  # Datos de prueba
YTrn_P <- as.factor(MLLabels[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(MLLabels[segmentoTest])  # Etiquetas de prueba
# Ranking con mRMR
rankingMRMR <-featureSelection(XTrn_P, YTrn_P, mode = "mrmr", vars_selected = colnames(XTrn_P))
# Guardar POR FILAS el ranking de características para esta partición
rankingSMRMR[particion, ] <- rankingMRMR[1:nVarsMAX]
# Evaluación por número de genes seleccionados
for (numGenes in seq_len(nVarsMAX)) {
# Seleccionar las mejores variables
topGenes <- colnames(XTrn_P)[rankingMRMR[1:numGenes]]
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=topGenes), decay = best_decay)
# Predicciones en Train
predTrain <- predict(modelo, subset(XTest_P, select=topGenes))
confMatTrain <- confusionMatrix(as.factor(predTrain), as.factor(YTest_P))
ACCTrnRL[particion, numGenes] <- confMatTrain$overall["Accuracy"]
# Predicciones en Test
predTest <- predict(modelo, subset(t(XTest), select=topGenes))
confMatTest <- confusionMatrix(as.factor(predTest), as.factor(YTest))
ACCTestRL[particion, numGenes] <- confMatTest$overall["Accuracy"] # se van añadiendo los valores por filas. Por tanto, para calcular la media de los accuracy para un número determinado de genes que hacerlo por columnas.  #print(confMatTest$overall[1])
#print(confMatTest$table)
}
# Graficar los resultados para la partición actual
num_genes <- 1:nVarsMAX
Trn_Acc <- ACCTrnRL[particion, 1:nVarsMAX]
Test_Acc <- ACCTestRL[particion, 1:nVarsMAX]
plot(num_genes, Trn_Acc, type = "l", col = "green", ylim = c(0.5, 1), ylab = "Accuracy",        xlab = "Número de genes seleccionados", main = paste("Partición", particion, "- RL con mRMR"))
lines(num_genes, Test_Acc, col = "black")
axis(1, at = 1:20, labels = 1:20)  # Configura los ticks y etiquetas del eje X
grid()
legend("topleft", legend = c("Train Accuracy", "Test Accuracy"),col=c("green","black"),lty = c(1, 1))
}
# Medias de Accuracy en las 5 particiones
ACCTrnRL_Mean <- colMeans(ACCTrnRL)
ACCTestRL_Mean <- colMeans(ACCTestRL)
# Resultados promedio
plot(1:nVarsMAX, ACCTrnRL_Mean, type = "l", col = "green", ylim = c(0.5, 1), xlim=c(1,20), xlab = "Número de genes seleccionados", ylab = "Accuracy", main = "Resultados Promedio RL con mRMR")
lines(1:nVarsMAX, ACCTestRL_Mean, col = "black")
axis(1, at = 1:20, labels = 1:20)  # Configura los ticks y etiquetas del eje X
grid()
legend("topleft", legend = c("Train Accuracy", "Test Accuracy"), col = c("green", "black"),
lty = c(1, 1))
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- MATRIZ[datosParaTRN, ] # Datos de entrenamiento
XTest_P <- MATRIZ[segmentoTest, ]  # Datos de prueba
YTrn_P <- as.factor(LABELS[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
View(XTrn)
View(XTrn)
View(XTrn_P)
View(XTrn_P)
huella
huella %in% rownames(MATRIZ)
MLMatrix
huella%in%MLMatrix
huella%in% rownames(MLMatrix)
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(t(XTrn_P), select=huella), decay = best_decay)
rownames( MATRIZ[datosParaTRN, ])
"IGHV3-73" %in% rownames(MATRIZ[datosParaTRN, ])
"IGHV3-73" %in% rownames(MATRIZ[segmentoTest, ])
foldIDx
seq_len(nfolds)
LABELS
datosParaTRN
rownames(MLMatrix)
colnames(MLMatrix)
rownames (MATRIZ) %in% colnames(MLMatrix)
sum(rownames (MATRIZ) %in% colnames(MLMatrix))
hulla
huella
huella %in% colnames (MATRIZ)
huella %in% rownames (MATRIZ)
MATRIZ[datosParaTRN, ]
rownames(MATRIZ[datosParaTRN, ])
huella %in% rownames(MATRIZ[datosParaTRN, ])
XTrn_P <- MATRIZ[,datosParaTRN] # Datos de entrenamiento
XTest_P <- MATRIZ[,segmentoTest]  # Datos de prueba
YTrn_P <- as.factor(LABELS[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(t(XTrn_P), select=huella), decay = best_decay)
View(XTrn_P)
View(XTrn_P)
huella %in% rownames(XTrn_O)
huella %in% rownames(XTrn_P)
subset(XTrn_P, select=huella)
subset(T(XTrn_P), select=huella)
subset(t(XTrn_P), select=huella)
data = subset(XTrn_P, select=huella)
data = subset(t(XTrn_P), select=huella)
type(data)
XTrn_P <- as.data.frame(t(MATRIZ[,datosParaTRN])) # Datos de entrenamiento
View(XTrn_P)
View(XTrn_P)
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
XTrn_P <- as.data.frame(t(MATRIZ[,datosParaTRN])) # Datos de entrenamiento
XTest_P <- as.data.frame(t(MATRIZ[,segmentoTest]))  # Datos de prueba
YTrn_P <- as.factor(LABELS[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
# Predicciones en Test
predTest <- predict(modelo, XTest_P[, huella])
confMatTest <- confusionMatrix(as.factor(predTest), YTest_P)
#print(confMatTest$table)
ACCTestRL[particion] <- confMatTest$overall["Accuracy"]
#print(ACCTestSVM[particion])
# Sumar la matriz de confusión al total
accTestSum <- accTestSum + confMatTest$table
set.seed(19)
nfolds <- 5  # Número de particiones en la validación cruzada
foldIDx <- cvGenStratified(LABELS, nfolds)  # Particiones estratificadas
# Vectores para almacenar métricas por partición
ACCTrnRL <- numeric(nfolds)
ACCTestRL <- numeric(nfolds)
# Matriz de confusión acumulada para el test
accTestSum <- matrix(0, nrow = 3, ncol = 3)
# Ranking con mRMR
huella <- c("IGHV3-73", "IGHV6-1", "UBQLN4P1", "PI4K2B", "RAPH1")
# Bucle para 5 particiones
for (particion in seq_len(nfolds)) {
# Crear particiones de entrenamiento y prueba
datosParaTRN <- which(foldIDx != particion)  # Índices de entrenamiento
segmentoTest <- which(foldIDx == particion)  # Índices de prueba
XTrn_P <- as.data.frame(t(MATRIZ[,datosParaTRN])) # Datos de entrenamiento
XTest_P <- as.data.frame(t(MATRIZ[,segmentoTest]))  # Datos de prueba
YTrn_P <- as.factor(LABELS[datosParaTRN])  # Etiquetas de entrenamiento
YTest_P <- as.factor(LABELS[segmentoTest])  # Etiquetas de prueba
# Entrenar modelo Regresión Logística multinomial
modelo <- multinom(YTrn_P ~ ., data = subset(XTrn_P, select=huella), decay = best_decay)
# Predicciones en Test
predTest <- predict(modelo, XTest_P[, huella])
confMatTest <- confusionMatrix(as.factor(predTest), YTest_P)
#print(confMatTest$table)
ACCTestRL[particion] <- confMatTest$overall["Accuracy"]
#print(ACCTestSVM[particion])
# Sumar la matriz de confusión al total
accTestSum <- accTestSum + confMatTest$table
}
print("Matriz de confusión acumulada en el test:")
accTestSum
predTest
table(LABELS)
table(LABELS)
library(BiocManager)
library(BiocManager)
library(org.Hs.eg.db)
#Incluir KnowSeq y las funciones proporcionadas
require(KnowSeq)
source("convert_to_counts.R")
source("geneOntologyEnrichment_updated.R")
source("knowseqReport_updated.R")
require("e1071")
require(CORElearn)
require("caret")
require("praznik")
library(caret)
load(file='samples')
samples$Sample.Type[samples$File.ID %in% samples_astrocytoma$File.ID] <- 'astrocytoma'
load(file='samples_astrocytoma')
samples$Sample.Type[samples$File.ID %in% samples_astrocytoma$File.ID] <- 'astrocytoma'
load(file='samples_mixed')
samples$Sample.Type[samples$File.ID %in% samples_mixed$File.ID] <- 'mixed_glioma'
load(file='samples_oligodendroglioma')
samples$Sample.Type[samples$File.ID %in% samples_oligodendroglioma$File.ID] <- 'oligodendroglioma'
View(samples)
install.packages("jsonlite")
install.packages("jsonlite")
library('jasonlite')
library('jsonlite')
clinical_data <- fromJSON("clinical.cart.2025-03-06.json")
df_clinical <- as.data.frame(clinical_data)
df_clinical.head()
df_clinical
View(df_clinical)
View(df_clinical[[1]][[79]])
View(df_clinical[[3]][[70]])
View(df_clinical[[6]][[71]])
View(df_clinical[[6]][[1]])
View(samples_astrocytoma)
View(samples_oligodendroglioma)
View(samples)
samples$File.ID  == 001ad307-4ad3-4f1d-b2fc-efc032871c7e
samples$File.ID  = '001ad307-4ad3-4f1d-b2fc-efc032871c7e'
load(file='samples')
load(file='samples_astrocytoma')
samples$Sample.Type[samples$File.ID %in% samples_astrocytoma$File.ID] <- 'astrocytoma'
load(file='samples_mixed')
samples$Sample.Type[samples$File.ID %in% samples_mixed$File.ID] <- 'mixed_glioma'
load(file='samples_oligodendroglioma')
samples$Sample.Type[samples$File.ID %in% samples_oligodendroglioma$File.ID] <- 'oligodendroglioma'
library('jsonlite')
clinical_data <- fromJSON("clinical.cart.2025-03-06.json")
df_clinical <- as.data.frame(clinical_data)
df_clinical
samples$File.ID  == '001ad307-4ad3-4f1d-b2fc-efc032871c7e'
View(df_clinical)
samples$File.ID  == 001ad307-4ad3-4f1d-b2fc-efc032871c7e
samples$File.Name  == 'eea25147-f2f3-5e19-b53d-7acac5f9fe56'
View(df_clinical[[1]][[319]])
any(samples$File.ID  == 001ad307-4ad3-4f1d-b2fc-efc032871c7e)
any(samples$File.ID  == '001ad307-4ad3-4f1d-b2fc-efc032871c7e')
any(samples$File.Name  == '001ad307-4ad3-4f1d-b2fc-efc032871c7e')
any(samples$File.Name  == '0d4a853e-cfe5-5d5b-ba5a-4066bacc3298')
any(samples$File.ID  == '0d4a853e-cfe5-5d5b-ba5a-4066bacc3298')
